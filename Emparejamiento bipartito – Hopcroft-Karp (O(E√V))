#include <iostream>
#include <vector>
#include <queue>
using namespace std;

bool bfs(vector<vector<int>>& adj, vector<int>& pairU, vector<int>& pairV, vector<int>& dist){
    queue<int> q;
    for(int u=0; u<pairU.size(); u++){
        if(pairU[u]==-1){dist[u]=0; q.push(u);}
        else dist[u]=INT_MAX;
    }
    int found=INT_MAX;
    while(!q.empty()){
        int u=q.front(); q.pop();
        if(dist[u]<found){
            for(int v: adj[u]){
                if(pairV[v]==-1) found=dist[u]+1;
                else if(dist[pairV[v]]==INT_MAX){
                    dist[pairV[v]]=dist[u]+1;
                    q.push(pairV[v]);
                }
            }
        }
    }
    return found!=INT_MAX;
}

bool dfs(int u, vector<vector<int>>& adj, vector<int>& pairU, vector<int>& pairV, vector<int>& dist){
    for(int v: adj[u]){
        if(pairV[v]==-1 || (dist[pairV[v]]==dist[u]+1 && dfs(pairV[v],adj,pairU,pairV,dist))){
            pairU[u]=v; pairV[v]=u;
            return true;
        }
    }
    dist[u]=INT_MAX;
    return false;
}

int hopcroftKarp(vector<vector<int>>& adj, int nU, int nV){
    vector<int> pairU(nU,-1), pairV(nV,-1), dist(nU);
    int result=0;
    while(bfs(adj,pairU,pairV,dist))
        for(int u=0; u<nU; u++)
            if(pairU[u]==-1 && dfs(u,adj,pairU,pairV,dist))
                result++;
    return result;
}

int main(){
    vector<vector<int>> adj={{0,1},{1,2},{0,2}};
    cout<<"Emparejamiento mÃ¡ximo (Hopcroft-Karp): "<<hopcroftKarp(adj,3,3)<<endl;
    return 0;
}
